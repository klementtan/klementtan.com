---
title: "Post: Inter Process Communication (IPC)"
categories:
  - Post
tags:
  - C++
excerpt: "Overview of the different IPC methods and their trade-offs"
---

In this post I will cover the various inter-process communication (IPC) methods and discuss their trade-offs.

## Signal

Overview: Asynchronous (sender don't need to coordinate with the receiver) notification system between process.

Functionality:
* Notification:
    1. Signal can be sent to a process or thread to notify an event
    2. When a signal is sent, the OS will interrupt the normal flow of execution.
    3. If the signal has previously registered signal handler, the signal handler will
    be executed otherwise the default signal handler will be executed.
* Block/Unblocking signals
    * Use `sigprocmask` to block signals. Blocked signals will not be delivered to the
    process until they are unblocked. `SIGKILL` and `SIGSTOP` cannot be unblocked.

Pros:
1. Lightweight IPC with little overhead

Cons:
1. Vulnerable to race conditions. A signal could be delivered to a process when it is already
executing a signal handler.
2. Could interrupt system calls
3. Signal handlers cannot have side effects or non-reentrant functions
  * non-reentrant functions are functions that will result in race condition if
  a function is interrupted mid-way through execution and called again even though
   the first function has not completed.
4. Mitigation:
  * Signals are pushed into a queue in the handler and immediately returned. Main handling of
  signals will occur outside of the signal handler.

## Sockets / Unix Domain Sockets

* Process can communicate via the network stack through IP/TCP
    * Each socket (unique REMOTE-IP, REMOTE-PORT, CLIENT-IP, CLIENT-PORT) is represented
    by a file descriptor
* On UNIX, provides UNIX domain socket that allows for TCP-like communication
through the kernel instead of the network stack.

## Message Queue

Overview: UNIX OS provides a message queue (pub-sub pattern) API for IPC.

Pros:
* Built in thread-safe message queue system
* Allows for blocking or non-blocking communication
* By default receiving message will block

Cons:
* Limited to only pub-sub pattern

## Pipes

Overview: one way FIFO communication channel (producer and consumer driven)

Anonymous Pipes:
* Used by executing process with `|`
* Pipes the stdout file descriptor of the LHS process to the stdin file RHS process
* Only last during the duration of the process

Name pipes:
* Instead of having `|` to specify the pipe, create a pipe on the file system to allow
process to explicitly refer to it.
  
Pros:
* If the consumer (RHS) close the pipes, the LHS will receive SIGPIPE signal when trying
to write to the pipe and will be killed by the signal handler.

## Shared Memory:

Overview: multiple process can share the same memory address in physical memory

Pros:
* Allow for synchronization primitives (shared mutex)

Cons:
* Memory access by the different process can vary in non-uniform memory access (**NUMA**)
* Could result in false sharing: additional unnecessary cache coherence protocol overhead.

## Memory-mapped file:
Overview: A segment of virtual memory that has been assigned byte-for-byte with
some file or file-like (represented using file descriptor). Instead of each representing
a frame in physical memory it will represent the file on disk.

IPC with mmap:
* Process can communicate through writing.

Cons:
* Could result in bugs with compiler optimisation (need to use `volatile` qualifier in c++)
removing redundant read-write to a memory
